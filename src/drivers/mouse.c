// SPDX-License-Identifier: GPL-2.0
// Copyright (C) 2025 Yula1234

#include <arch/i386/idt.h>

#include <fs/vfs.h>
#include <drivers/mouse.h>
#include <drivers/fbdev.h>
#include <drivers/virtio_gpu.h>

#include <kernel/input_focus.h>
#include <kernel/proc.h>
#include <kernel/poll_waitq.h>

#include <hal/io.h>
#include <hal/irq.h>

#include "mouse.h"

int mouse_x = 512, mouse_y = 384;
int mouse_buttons = 0;

static poll_waitq_t mouse_poll_waitq;

static uint8_t mouse_cycle = 0;
static uint8_t mouse_byte[3];

static int mouse_vfs_read(vfs_node_t* node, uint32_t offset, uint32_t size, void* buffer) {
    (void)node;
    (void)offset;

    if (!buffer) return -1;
    if (size < sizeof(mouse_state_t)) return -1;

    task_t* curr = proc_current();
    uint32_t owner_pid = fb_get_owner_pid();
    if (owner_pid != 0) {
        if (!curr || curr->pid != owner_pid) {
            return 0;
        }
    } else {
        uint32_t focus_pid = input_focus_get_pid();
        if (focus_pid > 0 && curr && curr->pid != focus_pid) {
            return 0;
        }
    }

    uint32_t flags;
    __asm__ volatile("pushfl; popl %0; cli" : "=r"(flags) : : "memory");

    mouse_state_t st;
    st.x = mouse_x;
    st.y = mouse_y;
    st.buttons = mouse_buttons;

    __asm__ volatile("pushl %0; popfl" : : "r"(flags) : "memory");

    *(mouse_state_t*)buffer = st;
    return (int)sizeof(mouse_state_t);
}

int mouse_poll_ready(task_t* task) {
    if (!task) return 0;
    uint32_t owner_pid = fb_get_owner_pid();
    if (owner_pid != 0) {
        return task->pid == owner_pid;
    }
    uint32_t focus_pid = input_focus_get_pid();
    if (focus_pid > 0 && task->pid != focus_pid) {
        return 0;
    }
    return 1;
}

int mouse_poll_waitq_register(poll_waiter_t* w, task_t* task) {
    if (!w || !task) return -1;
    return poll_waitq_register(&mouse_poll_waitq, w, task);
}

void mouse_poll_notify_focus_change(void) {
    poll_waitq_wake_all(&mouse_poll_waitq);
}

static vfs_ops_t mouse_ops = { .read = mouse_vfs_read };
static vfs_node_t mouse_node = { .name = "mouse", .ops = &mouse_ops, .size = sizeof(mouse_state_t) };

void mouse_vfs_init(void) {
    poll_waitq_init(&mouse_poll_waitq);
    devfs_register(&mouse_node);
}

void mouse_wait(uint8_t type) {
    uint32_t timeout = 100000;
    if (type == 0) {
        while (timeout--) if ((inb(0x64) & 1) == 1) return;
    } else {
        while (timeout--) if ((inb(0x64) & 2) == 0) return;
    }
}

uint32_t mouse_cursor_classic[144] = {
    0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0x000000, 0xFFFFFF, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0x000000, 0xFFFFFF, 0xFFFFFF, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0x000000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0x000000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0x000000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0x000000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0x000000, 0xFFFFFF, 0xFFFFFF, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0x000000, 0xFFFFFF, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0x000000, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
    0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF,
};

uint32_t icon_terminal[256] = {
    0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0x00FF00, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0x00FF00, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x00FF00, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0x00FF00, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0x00FF00, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x00FF00, 0x00FF00, 0x00FF00, 0x00FF00, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D
};

uint32_t icon_monitor[256] = {
    0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x007ACC, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x007ACC, 0x007ACC, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0x007ACC, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x007ACC, 0xFF00FF, 0xFF00FF, 0x007ACC, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0x007ACC, 0x007ACC, 0xFF00FF, 0x007ACC, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x007ACC, 0x007ACC, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0x007ACC, 0x007ACC, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x007ACC, 0x007ACC, 0x007ACC, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0xFF00FF, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x2D2D2D,
    0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D, 0x2D2D2D
};

void mouse_write(uint8_t a) {
    mouse_wait(1);
    outb(0x64, 0xD4);
    mouse_wait(1);
    outb(0x60, a);
}

uint8_t mouse_read() {
    mouse_wait(0);
    return inb(0x60);
}

void mouse_irq_handler(registers_t* regs) {
    (void)regs;
    uint8_t status = inb(0x64);
    
    if (!(status & 0x01)) return;

    uint8_t data = inb(0x60);

    if (status & 0x20) {
        mouse_process_byte(data);
    }
}

void mouse_init() {
    uint8_t status;

    mouse_wait(1);
    outb(0x64, 0xA8);

    mouse_wait(1);
    outb(0x64, 0x20);
    status = mouse_read() | 2;
    status &= ~0x20;          

    mouse_wait(1);
    outb(0x64, 0x60);
    mouse_wait(1);
    outb(0x60, status);

    mouse_write(0xF6);
    mouse_read();     

    mouse_write(0xF4);
    mouse_read();     

    irq_install_handler(12, mouse_irq_handler);

    outb(0xA1, inb(0xA1) & ~(1 << 4)); // Slave: IRQ 12
    outb(0x21, inb(0x21) & ~(1 << 2)); // Master: Cascade
}

void mouse_process_byte(uint8_t data) {
    if (mouse_cycle == 0 && !(data & 0x08)) return;

    mouse_byte[mouse_cycle++] = data;

    if (mouse_cycle == 3) {
        mouse_cycle = 0;
        
        if (mouse_byte[0] & 0x80 || mouse_byte[0] & 0x40) return;

        int32_t rel_x = (int8_t)mouse_byte[1];
        int32_t rel_y = (int8_t)mouse_byte[2];

        mouse_buttons = mouse_byte[0] & 0x07;

        mouse_x += rel_x;
        mouse_y -= rel_y;

        int max_w = (int)fb_width;
        int max_h = (int)fb_height;
        if (virtio_gpu_is_active()) {
            const virtio_gpu_fb_t* fb = virtio_gpu_get_fb();
            if (fb && fb->width > 0u && fb->height > 0u) {
                max_w = (int)fb->width;
                max_h = (int)fb->height;
            }
        }
        if (max_w < 1) max_w = 1;
        if (max_h < 1) max_h = 1;

        if (mouse_x < 0) mouse_x = 0;
        if (mouse_y < 0) mouse_y = 0;
        if (mouse_x >= max_w) mouse_x = max_w - 1;
        if (mouse_y >= max_h) mouse_y = max_h - 1;

        poll_waitq_wake_all(&mouse_poll_waitq);
    }
}
