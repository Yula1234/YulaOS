This document describes the kernel coding and formatting style used in this project. The goal of the style is to make low-level code easy to audit, easy to review, and hard to misread. Readability is treated as a correctness feature: formatting, whitespace, naming, and decomposition are expected to reduce cognitive load and to make control flow and ownership obvious at a glance.

Indentation uses 4 spaces per level and never tabs. Lines should not be artificially packed: prefer a calm, spacious layout with clear structure. The file layout is conventional and stable: includes are grouped and separated by empty lines; major declarations are separated by empty lines; sections within a file are visually distinct. Keep braces in a consistent style, with opening braces on the same line as the statement and closing braces aligned. Avoid trailing whitespace and avoid random vertical alignment tricks that break when names change.

Whitespace and “air” are intentional. Within a function, separate logically different steps with an empty line: input validation, local variable preparation, resource acquisition, locking scopes, external calls, state mutation, error handling, and return. Even small phase boundaries should be visible; tightly stacked unrelated statements are discouraged. Conversely, do not insert blank lines inside a single tight logical unit where the reader expects sequential continuity.

Expressions and conditions are formatted to emphasize structure and safety. Long boolean conditions are written across multiple lines with the operator at the beginning of the continued line, so each clause is visually symmetric and diffs remain clean when clauses are added or removed. Guard clauses are preferred: fail fast, return early, and keep the main path clear. Complex return expressions are avoided when they hide intermediate meaning; instead, name intermediate results and check them in separate steps.

Function calls with many arguments are formatted for readability and stable diffs. Do not place a long argument list on one line. Break the call into multiple lines and group arguments by meaning, keeping each line short and consistent. Avoid extreme “argument towers” where every argument is on its own line unless it actually improves clarity; grouping should look deliberate and human, typically placing two to four related arguments per line. When calling an external subsystem, split the call, the return code capture, and the return code check into separate phases with whitespace between them.

Variable declarations should be close to their first use, but the code should not become visually noisy. Prefer declaring a small block of locals, then leaving a blank line before the next phase. Use const where it strengthens reasoning and communicates intent. Prefer explicit types in core logic when they help the reader understand exact width and signedness; use type inference only when the type is obvious and does not hide important information.

Naming is expected to be consistent and descriptive. Types, functions, and variables should be named so that the reader can infer responsibility and ownership. Avoid unclear abbreviations. For fields, a trailing underscore is used for class members. Boolean state should read naturally and avoid double negation. Error and result values should be explicit rather than encoded in magic numbers.

Naming reflects the conceptual hierarchy of the system. Concrete types, classes, and structs are written in PascalCase (e.g., SpinLock, MutexGuard) to distinguish them from the operational flow. Variables, function names, and parameters use snake_case to maintain a fluid reading rhythm. Member variables must carry a trailing underscore to eliminate ambiguity between internal state and temporary locals. Constants and enumerators use uppercase snake_case to indicate their immutable nature. Clear, intent-revealing names are preferred over brevity; avoid cryptic abbreviations that require the reader to consult external documentation.

Ownership and lifetime must be visible in the code structure. Prefer RAII wrappers and move-only handles for resources that require cleanup. When a resource can be partially initialized or conditionally armed, make the state explicit and centralize cleanup in a single reset or destructor path. Keep destruction paths predictable, and avoid scattered cleanup code across multiple returns. When moving from an object, ensure the moved-from state is reset to a benign, well-defined state.

Locking and concurrency should be structured to minimize the time a lock is held and to make critical sections obvious. Keep lock guards in small lexical scopes. Use explicit nested scopes for critical sections, and separate them from surrounding phases by empty lines. Avoid mixing unrelated logic into a locked section. When working with shared structures, prefer patterns that keep invariants localized and that make it clear which data is protected by which lock.

Templates and generic helpers should be written conservatively and with a focus on compile-time safety. Prefer small helpers with clear contracts. Static assertions are used to enforce assumptions early. Implementation details are kept private and grouped logically. Internal helpers are named to reflect behavior rather than mechanics.

C and C++ boundary code must preserve ABI and remain disciplined. C-facing APIs keep simple signatures and stable layouts. C++-only extensions are placed behind __cplusplus guards. Conversions between C and C++ representations should be minimal, explicit, and easy to audit. When mapping rich internal errors to a C ABI boundary, perform that mapping at the boundary and keep internal code using the richer representation.

Finally, keep functions and types small enough to read comfortably. When a function begins to mix several responsibilities, split it. When a pattern repeats, extract a helper rather than duplicating blocks. The style is intentionally strict about structure and spacing because the codebase is kernel-level and changes must remain reviewable and safe over time.